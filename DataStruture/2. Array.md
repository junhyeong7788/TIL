# Array
: 가장 기본적인 자료 구조
- 여러 개의 변수를 담는 공간으로 이해가능
- 배열은 인덱스(index)가 존재, 인덱스는 0부터 시작한다.
- 특정한 인덱스에 직접적으로 접근 가능 -> 수행시간 : O(1)

# 배열 특징
- 컴퓨터의 메인 메모리에서 배열의 공간은 연속적으로 할당한다.
장점 : cache 히트 가능성이 높으며, 조회가 빠르다.
단점 : 배열의 크기를 미리 지정해야하는 것이 일반적이므로, 데이터의 추가 및 삭제에 한계가 있다.

### 메모리 관점
- 휘발성 메모리 ( RAM - Random Access Memory)
	- 프로그램 동작, 변수 생성이 저장
	- 데이터 접속을 랜덤으로 할 수 있어서 동작 속도가 빠르다
- 비휘발성 메모리 ( HDD )

- 배열을 생성할 때 메모리에 배열의 크기를 미리 알려준다
	- 하지만 **JS, Python은 개발자 대신 핸들링**을 해줘서 배열의 길이를 생각할 필요가 없다.
	- 그래서 프로그래밍 동작속도는 느려질 수 있다.
- 컴퓨터는 이 배열의 길이를 저장하고 어디서 시작하는가 생각한다.

# 연결리스트 (linked list)
- 컴퓨터의 메인 메모리상에서 주소가 연속적이지 않다.
- 배열과 다르게 크기가 정해져 있지 않고, 리스트의 크기는 동적으로 변경가능
장점 : 포인터를 통해 다음 데이터의 위치를 가리킨다는 점에서 삽입과 삭제가 간편하다.
단점 : 원소를 검색할 때는 앞에서부터 원소를 찾아야 하므로, 데이터 검색 속도가 느리다.


# 파이썬의 리스트(list) 자료형 
: 파이썬에서는 리스트 자료형을 제공
- 컴퓨터 공학에서의 연결리스트와 다른 의미를 가짐
- 일반적인 프로그래밍 언어에서의 배열로 이해가능
- 파이썬의 리스트는 배열처럼 임의의 인덱스를 이용하여 직접적인 접근이 가능하다.

- 동적배열
- 배열의 용량이 가득차면, 자동으로 크기를 증가시킨다.
- 내부적으로 포인터를 사용하여, 연결리스트의 장점도 가지고 있다.
- 배열 혹은 스택의 기능이 필요할 때 리스트 자료형을 그대로 사용할 수 있다.
- 큐의 기능을 제공하지 못한다.

# 리스트 컴프리헨션 ( List Comprehension )
- 파이썬에서는 임의의 크기를 가지는 배열을 만들 수 있다.

### 기본 구조
`[<표현식> for <변수명> in <시퀀스>` 
- 표현식 : 각 반복마다 계산되는 값
- 변수명 : 시퀀스의 각 원소를 순환하며 값을 할당 받음
- 시퀀스 : for 루프에서 반복되는 리스트, 문자열, 튜플 등이다.

```
# [0, 0, 0, 0, 0]
n = 5
arr = [0]*n
print(arr)

# [0, 1, 2, 3, 4]
n = 5
arr = [i for i in range(n)]
print(arr)
```

# 배열을 초기화할 때 유의할 점
- 리스트는 기본적으로 메모리 주소를 반환한다.
- 따라서 단순히 `[[0]*m]*n` 형태로 배열을 초기화하면 안된다.
	- n개의 `[0]*m` 리스트는 모두 같은 객체로 인식
	- 같은 메모리를 (동일한 리스트를) 가리키는 n개의 원소를 담는 리스트가 된다.

# Time complexity
### Reading
- 배열에서 읽는 건 아주 빠르다
- 많은 자료를 읽어야한다면 배열이 좋다 (Random Access)
- 길이와 상관없이 인덱스에서 요소를 읽어내는 속도는 동일하다

### Search
- 랜덤 엑세스가 있어서 박스에 쉽게 접근할 수 있는데, 그 박스 안의 값은 모르는 상황이다.
- 배열의 아이템을 하나 하나 열어보고 체크하는 과정을 거쳐야한다.
- 시간이 아주 오래 걸린다.

### Insert ( add ), Delete
- 메모리 공간을 확보해야한다.
- 보통의 시나리오
	- 중간에 값 추가 : 존재하는 값들을 밀고 추가하낟.
	- 중간에 값 삭제 : 존재하는 값을 삭제 후 채워줘야한다.
- 여러가지 일들을 수행해야하기 때문에 동작 시간이 오래 걸린다.

# 마무리
- 시간 복잡성면에서 보면 배열을 reading 하는 건 가장 빠르지만, search, insert, delete하는 과정은 오래 걸린다는 것을 알 수 있다.