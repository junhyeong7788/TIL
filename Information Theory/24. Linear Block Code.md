- 선형 블록 코드는 디지털 통신에서 오류 검출 및 수정에 사용되는 부호화 방식 중 하나이다.

#### 주요 부호화 방식의 종류
- 부호화 방식(Encoding Scheme) : 데이터를 특정한 형식으로 변환하는 방법을 의미
	- 이는 원본 데이터를 다른 형식으로 변환하여 저장하거나 전송할 때 사용
	- 부호화 방식은 정보의 효율적인 저장, 전송, 보안 등을 위해 다양한 형태로 사용

1. 소스 부호화 (Source Coding)
- 데이터 압축을 통해 저장공간을 절약하거나 전송속도를 높이기 위한 방식
	- 예 : 허프만 코딩, 런렝스 코딩
2. 채널 부호화 (Channel Coding)
- 데이터 전송 중에 발생할 수 있는 오류를 감지하고 수정하기 위한 방식
	- 예 : 해밍코드, 순방향 오류 수정 코드
	- **해밍 코드(Hamming Code)**:
		- 데이터 전송 중 발생하는 단일 비트 오류를 감지하고 수정할 수 있는 방식입니다.
		- 예를 들어, 4비트 데이터 '1011'을 해밍 코드로 부호화하면, 추가적인 패리티 비트가 더해져 '1011010'로 전송됩니다. 수신 측에서 오류를 감지하고 원래 데이터를 복원할 수 있습니다.
3. 선형 부호화 (Linear Coding)
- 입력 데이터를 선형 결합하여 출력 데이터를 생성하는 방식
	- 예 : 선형 블록 코드, 선형 피드백 시프트 레지스터
4.  대수적 부호화
- 대수적 구조를 사용하여 데이터를 부호화하는 방식
	- 리드-솔로몬 코드, 사이클릭 코드

# Linear Block Code
### 정의
- 차원 : 선형 블록 코드는 $(F_2)$ 위의 $n$-차원 부분 공간이다.
	- 여기서 $F_2$는 이진 필드를 의미하며, 0과 1의 값을 가짐
- 시스템 코드 : 메시지 비트는 코드워드에 직접 포함됨
	- 즉, 코드워드는 메시지 비트와 패리티 비트로 구성됨

![[Pasted image 20240612203647.png]]
1. 메시지 비트 (K) 비트 : $m_0, m_1, ..., m_{k-1}$
2. 코드워드 (n) 비트 : $b_0, b_1, \ldots, b_{n-k-1}$
- 코드워드는 $k$개의 메시지 비트와 $n-k$개의 패리티 비트로 구성
#### 벡터와 행렬의 정의
- **벡터(Vector)**: 벡터는 한 줄로 나열된 숫자의 배열로, 일반적으로 열 벡터(column vector) 또는 행 벡터(row vector)로 표현됩니다.
    
    - 예: 열 벡터 $\mathbf{v} = \begin{pmatrix} v_1 \\ v_2 \\ v_3 \end{pmatrix}$​​​
- **행렬(Matrix)**: 행렬은 숫자가 직사각형 배열로 배치된 것으로, 일반적으로 $m \times n$ 행렬이라고 합니다. 여기서 $m$은 행의 수, $n$은 열의 수입니다.
    
    - 예: 행렬 $\mathbf{A} = \begin{pmatrix} a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} \end{pmatrix}$
#### 벡터-행렬 곱셈 규칙

- 벡터 $\mathbf{v}$가 $1 \times n$ 행 벡터이고, 행렬 $\mathbf{A}$가 $n \times m$ 행렬이라면, 결과는 $1\times m$ 행 벡터가 됩니다.

-  예시
	- 행 벡터 $\mathbf{v}$와 행렬 $\mathbf{A}$가 다음과 같다고 가정합시다:

		- $\mathbf{v} = \begin{pmatrix} v_1 & v_2 & v_3 \end{pmatrix}, \quad \mathbf{A} = \begin{pmatrix} a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} \end{pmatrix}$

	- 벡터 $\mathbf{v}$와 행렬 $\mathbf{A}$의 곱은 다음과 같이 계산됩니다:

		- $\mathbf{v} \mathbf{A} = \begin{pmatrix} v_1 & v_2 & v_3 \end{pmatrix} \begin{pmatrix} a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} \end{pmatrix}$

	- 곱셈의 결과는 다음과 같습니다:

		- $\mathbf{v} \mathbf{A} = \begin{pmatrix} v_1 a_{11} + v_2 a_{21} + v_3 a_{31} & v_1 a_{12} + v_2 a_{22} + v_3 a_{32} & v_1 a_{13} + v_2 a_{23} + v_3 a_{33} \end{pmatrix}$

	- 각 요소는 벡터의 요소와 행렬의 해당 열의 요소 간의 곱셈과 합산으로 계산됩니다.
#### 열 벡터와 행렬의 곱셈

- 열 벡터 $\mathbf{v}$와 행렬 $\mathbf{A}$의 곱셈도 비슷하게 계산할 수 있습니다. 벡터 $\mathbf{v}$가 $n \times 1$ 열 벡터이고, 행렬 A\mathbf{A}A가 $m \times n$ 행렬이라면, 결과는 $m \times 1$ 열 벡터가 됩니다.

- 예시

	- 열 벡터 $\mathbf{v}$와 행렬 $\mathbf{A}$가 다음과 같다고 가정합시다:
		- $\mathbf{v} = \begin{pmatrix} v_1 \\ v_2 \\ v_3 \end{pmatrix}, \quad \mathbf{A} = \begin{pmatrix} a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} \end{pmatrix}$

	- 곱셈의 결과는 다음과 같습니다:
		- $\mathbf{A} \mathbf{v} = \begin{pmatrix} a_{11} v_1 + a_{12} v_2 + a_{13} v_3 \\ a_{21} v_1 + a_{22} v_2 + a_{23} v_3 \\ a_{31} v_1 + a_{32} v_2 + a_{33} v_3 \end{pmatrix}$
### 패리티 비트 (Parity bits)
- 데이터 전송 중에 오류를 검출하는 단순하고 효율적인 방법 중 하나
	- 전송되는 데이터 비트에 추가되어, 수신자가 데이터의 무결성을 확인할 수 있도록 도와줌
![[Pasted image 20240612204542.png]]
- $b_i = p_{0i} m_0 + p_{1i} m_1 + \cdots + p_{k-1,i} m_{k-1}$
- 이는 벡터-행렬 곱으로 다음과 같이 표현할 수 있다.
- $b_i = [m_0 \; m_1 \; \cdots \; m_{k-1}] \begin{bmatrix} p_{0i} \\ p_{1i} \\ \vdots \\ p_{k-1,i} \end{bmatrix}$
- 이 표현은 패리티 비트가 메시지 비트의 선형 결합임을 나타냄
	- 선형결합 : 패리티 비트가 메시지 비트의 특정 조합에 의해 생성된다는 것을 의미

#### 설명
1. 메시지 비트 : 원래 전달하려는 데이터 비트
2. 페리티 비트 : 오류 검출 및 수정을 위해 메시지 비트의 선형 결합으로 생성되는 비트
	- 각 패리티 비트$b_i$는 메시지 비트$m$들과 패리티 생성 행렬의 열 벡터$p_i$의 내적이다.
	- 내적 : 두 벡터의 내적은 각 성분별 곱의 합으로 정의, 예를 들어, 두 벡터 a와 b가 다음과 같을 때, 
		- $\mathbf{a} \cdot \mathbf{b} = a_1 b_1 + a_2 b_2 + a_3 b_3$ 로 계산된다.
3. 코드워드 : 메시지 비트와 패리티 비트가 결합된 형태로 전송되는 최종 비트 시퀀스이다.

### 정리
- 메시지비트가 주어지면, 패리티 비트는 메시지 비트의 선형결합으로 계산
- 코드워드는 메시지 비트와 패리티 비트의 결합으로 구성

# Matrix Representation (행렬 표현)
- 선형 블록 코드의 행렬 표현을 설명
### 기호 설명
1.	Information (정보): 메시지 비트로 구성된 벡터 $m$
- $\mathbf{m} = [m_0, m_1, \ldots, m_{k-1}]$

2.	Parity (패리티): 패리티 비트로 구성된 벡터  ${b}$
- $\mathbf{b} = [b_0, b_1, \ldots, b_{n-k-1}]$

3.	Codeword (코드워드): 전체 코드워드로, 패리티 비트와 메시지 비트를 포함한 벡터  ${c}$
- $\mathbf{c} = [c_0, c_1, \ldots, c_{n-1}]$
	- 여기서 코드워드는 패리티 비트와 메시지 비트로 구성됩니다.
![[Pasted image 20240612205401.png]]

### 코드워드 생성
코드워드  $\mathbf{c}$ 는 메시지 비트  $\mathbf{m}$ 와 패리티 비트  $\mathbf{b}$ 를 결합하여 생성됩니다.

1.	패리티 비트 계산:
- 패리티 비트는 메시지 비트와 패리티 행렬  $\mathbf{P}$ 를 곱하여 계산합니다.
	- $\mathbf{b} = \mathbf{mP}$

2.	코드워드  $\mathbf{c}$  생성:
- 코드워드는 패리티 비트와 메시지 비트를 결합하여 생성됩니다.
	- $\mathbf{c} = [\mathbf{b} | \mathbf{m}] = [\mathbf{mP} | \mathbf{m}]= \mathbf{m}[\mathbf{P} | \mathbf{I_k}] = \mathbf{mG}$
- 이 과정을 행렬 형태로 표현하면 다음과 같습니다.
	- $\mathbf{c} = \mathbf{mG}$
	- 여기서  $\mathbf{G}$ 는 생성 행렬입니다.

### 생성 행렬  $\mathbf{G}$
- 생성 행렬  $\mathbf{G}$ 는 패리티 행렬  $\mathbf{P}$ 와 단위 행렬  $\mathbf{I_k}$ 로 구성됩니다.
	- $\mathbf{G} = [\mathbf{P} | \mathbf{I_k}] (k*n)$
- 예시로 패리티 행렬  $\mathbf{P}$ 가 주어졌을 때:

$$\mathbf{P} = \begin{bmatrix}
p_{00} & p_{01} & \cdots & p_{0,n-k-1} \\
p_{10} & p_{11} & \cdots & p_{1,n-k-1} \\
\vdots & \vdots & \ddots & \vdots \\
p_{k-1,0} & p_{k-1,1} & \cdots & p_{k-1,n-k-1} \\
\end{bmatrix}$$
- k번째 행이 선형 독립이다.

### 주요 포인트
1.	메시지 비트  $\mathbf{m}$ : 정보 비트입니다.
2.	패리티 비트  $\mathbf{b}$ : 메시지 비트를 기반으로 계산된 비트입니다.
3.	코드워드  $\mathbf{c}$ : 패리티 비트와 메시지 비트를 결합한 것입니다.
4.	생성 행렬  $\mathbf{G}$ : 코드워드를 생성하는 데 사용됩니다. 이는 패리티 행렬  $\mathbf{P}$ 와 단위 행렬  $\mathbf{I_k}$ 로 구성됩니다.

### 예시 계산
1.	메시지 비트:  $\mathbf{m} = [m_0, m_1, \ldots, m_{k-1}]$
2.	패리티 비트 계산:  $\mathbf{b} = \mathbf{mP}$
3.	코드워드 생성:  $\mathbf{c} = [\mathbf{mP} | \mathbf{m}] = \mathbf{mG}$

- 이와 같이 선형 블록 코드는 메시지 비트와 패리티 비트를 결합하여 신뢰성 있는 데이터 전송을 가능하게 합니다.
#### 패리티 행렬 (Parity Matrix)
- 오류 검출 및 수정 코드에서 사용되는 행렬, 주어진 코드의 패리티 비트를 생성하고 오류를 검출하는 데 사용 
- 특히 해밍코드와 같은 선형 블록코드에서 중요한 역할을 함

- 구성
	- 패리티행렬 $H$는 $(n−k)×n$ 행렬로, 여기서 $n$은 코드워드의 길이, $k$는 원본 데이터 비트의 길이입니다.
	- 각 행은 독립적이고 선형적으로 결합되어야 합니다.
- 예시
	- 해밍 코드(7,4)에서는 7비트의 코드워드 중 4비트가 데이터 비트이고 3비트가 패리티 비트입니다. 이에 대한 패리티 행렬 $H$는 다음과 같이 구성됩니다:
$$H = \begin{pmatrix} 1 & 0 & 0 & 1 & 0 & 1 & 1 \\ 0 & 1 & 0 & 1 & 1 & 0 & 1 \\ 0 & 0 & 1 & 0 & 1 & 1 & 1 \end{pmatrix}$$

#### 단위 행렬 (Identity Matrix)
- 주대각선이 모두 1이고 나머지 요소가 모두 0인 정사각 행렬
- 행렬 연산에서 항등원 역할을 하며, 어떤 행렬 A와 곱해도 A가 그대로 유지

- 구성
	- 단위 행렬 $I_n$은 $n\times n$ 행렬로, 다음과 같은 형태를 가집니다:
$$I_n = \begin{pmatrix} 1 & 0 & 0 & \cdots & 0 \\ 0 & 1 & 0 & \cdots & 0 \\ 0 & 0 & 1 & \cdots & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & 0 & \cdots & 1 \end{pmatrix}$$
-  예시
	- 3x3 단위 행렬 I3I_3I3​는 다음과 같습니다:
$$I_3 = \begin{pmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{pmatrix}$$
#### 패리티 행렬과 단위 행렬의 사용
- **패리티 행렬**:
    - 오류 검출 및 수정: 패리티 행렬을 사용하여 수신된 코드워드의 오류를 검출하고 위치를 식별합니다.
    - 예를 들어, 코드워드 $\mathbf{c}$가 주어졌을 때, $\mathbf{c} \cdot H^T = \mathbf{0}$가 성립하면 오류가 없음을 의미합니다.
- **단위 행렬**:
    - 행렬 연산의 항등원: $A \cdot I = I \cdot A = A$
    - 코딩 이론에서, 생성 행렬의 구성에 사용되어 데이터 비트를 포함한 코드워드를 형성합니다.
- 정리
	- 패리티행렬 : 오류 검출 및 수정에 사용되는 행렬로, 코드워드의 패리티 비트를 생성하고 오류를 검출하는 역할을 함
	- 단위 행렬 : 주 대각선이 1이고 나머지가 0인 행렬로, 행렬연산에서 항등원 역할을 하며, 다른 행렬과 곱해도 원래 행렬이 유지됨.
# Encoding and Decoding (부호화 및 복호화)

### Encoding (부호화)
![[Pasted image 20240612210014.png]]

1. 메시지 벡터 ( $\mathbf{m}$ )
- 메시지 벡터는 전송할 정보 비트들로 구성됩니다.
	- $\mathbf{m} = [m_0, m_1, \ldots, m_{k-1}]$
		- 이 벡터는  $2^k$ 개의 가능한 메시지 중 하나입니다.
		- 비트의 조합 : $k$개의 비트가 있을 때, 각 비트는 독립적으로 0또는 1의 값을 가질 수 있으므로 총 가능한 조합의 수는 $2^k$가 된다.
			- 예 : 3개의 비트가 있다. 각 비트는 0또는 1일 수 있다.
				- 가능한 메시지 : ${000,001,010,011,100,101,111}$
				- 총 가능한 조합의 수 : $2^3=8$ 

2. 생성 행렬  $\mathbf{G}$
- 생성 행렬는 메시지 벡터를 코드워드로 변환하는 데 사용됩니다. 코드워드는 다음과 같이 계산됩니다:
	- $\mathbf{c} = \mathbf{mG}$

3. 선형성 (Linearity)
- 선형 블록 코드의 중요한 특성 중 하나는 선형성입니다. 
- 두 메시지 벡터  $\mathbf{m_i}$ 와 $\mathbf{m_j}$ 에 대해, 대응하는 코드워드  $\mathbf{c_i}$ 와  $\mathbf{c_j}$ 는 다음과 같은 관계를 가집니다:
	- $\mathbf{c_i} + \mathbf{c_j} =\mathbf{m_i}\mathbf{G} + \mathbf{m_j}\mathbf{G}= (\mathbf{m_i} + \mathbf{m_j}) \mathbf{G}$
- 이것은 코드워드들의 합이 대응하는 메시지 벡터들의 합에 생성 행렬  $\mathbf{G}$ 를 곱한 것과 같음을 의미합니다.

### Decoding (복호화)
- 부호화된 데이터를 원래의 형식으로 되돌리는 과정
	- 이는 데이터 전송이나 저장 후에 원본 데이터를 정확히 복원하기 위해 필수적인 단계
	- 복호화 과정은 부호화 과정에서 사용된 방법에 따라 다르게 적용

- 주요 목적
1. 데이터 복원 : 부호화된 데이터를 원래의 형태로 복원하여 사용자가 이해할 수 있도록 함
2. 오류 검출 및 수정 : 전송 중 발생한 오류를 검출하고 수정하여 원본 데이터를 정확하게 복원함

- 방식
1. 소스 복호화 : 데이터 압축 후 압축된 데이터를 원래의 형태로 되돌리는 과정
	- 허프만 복호화, 런렝스 복호화
	- **허프만 복호화(Huffman Decoding)**:
	    - 허프만 코딩된 데이터 '000001010110'을 복호화하여 원래의 문자열 'AAAAABBC'로 복원하는 과정입니다. 복호화 알고리즘은 허프만 트리를 사용하여 각 비트 시퀀스를 원래의 문자로 변환합니다.
2. 채널복호화 : 전송 중에 발생할 수 있는 오류를 감지하고 수정하여 원래의 데이터를 복원하는 과정
	- 해밍 코드 복호화, 리드-솔로몬 코드 복호화
	- **해밍 코드 복호화(Hamming Decoding)**:
		- 해밍 코드로 부호화된 데이터 '1011010'을 수신한 후, 복호화 알고리즘은 추가된 패리티 비트를 사용하여 오류를 검출하고 수정합니다. 이 과정을 통해 원래의 4비트 데이터 '1011'을 복원합니다.

- 요약
	- 데이터 전송 및 저장의 신뢰성을 높이며, 원본 데이터를 정확하게 재현할 수 있도록 돕는다.
	- 복호화는 소스 복호화와 채널 복호화로 나뉘며, 각각의 목적에 맞는 다양한 방법이 사용


1. 패리티 검사 행렬  $\mathbf{H}$
- 패리티 검사 행렬  $\mathbf{H}$ 는 수신된 코드워드가 오류가 있는지 검사하는 데 사용됩니다. 
- 패리티 검사 행렬은 다음과 같이 정의됩니다:
	- $\mathbf{H} = [\mathbf{I_{n-k}} | \mathbf{P^T}]((n-k*n)$
- 여기서  $\mathbf{I_{n-k}}$ 는  $(n-k) \times (n-k)$  단위 행렬이고,  $\mathbf{P^T}$ 는 패리티 행렬  $\mathbf{P}$ 의 전치 행렬입니다.

2. 오류 검출
- 수신된 코드워드  $\mathbf{r}$ 에 대해, 패리티 검사 행렬  $\mathbf{H}$ 를 곱하여 시드롬  $\mathbf{s}$ 를 계산합니다:
	- $\mathbf{s} = \mathbf{rH^T}$
- 만약  $\mathbf{s} = 0$ 이면, 수신된 코드워드에 오류가 없음을 의미합니다.

3. 선형성 확인
- 생성 행렬  $\mathbf{G}$ 와 패리티 검사 행렬  $\mathbf{H}$ 의 관계는 다음과 같습니다:
	- $\mathbf{H G^T} = 0$
- 이 관계를 통해 코드워드가 유효한지 확인할 수 있습니다.
![[Pasted image 20240612210349.png]]

- 이 과정을 통해 선형 블록 코드의 부호화 및 복호화 과정을 이해할 수 있으며, 이를 통해 데이터 전송 시 발생할 수 있는 오류를 효과적으로 검출하고 수정할 수 있습니다.

# Repetition code (반복 코드)
- 가장 간단한 형태의 블록 코드 중 하나로, 단일 비트를 여러 번 반복하여 오류를 검출하고 수정할 수 있는 능력을 갖춘다.
	- 단일 비트 : 0과 1의 값을 가질 수 있는 가장 작은 단위의 정보를 의미
### 특성
• **(n, 1) 블록 코드**: 반복 코드는 ( n ) 비트 길이의 코드워드를 생성하지만, 실제 정보 비트는 1비트입니다.
• **코드워드**: 단 두 개의 코드워드를 가집니다:
	• ( $(0, 0, \ldots, 0)$ ): 모든 비트가 0인 코드워드
	• ( $(1, 1, \ldots, 1)$ ): 모든 비트가 1인 코드워드

### (5, 1)코드 예시
1. 생성 행렬 ( $\mathbf{G}$ )
- 생성 행렬는 정보 비트를 코드워드로 변환하는 데 사용됩니다.
	- $\mathbf{G} = [1 \; 1 \; 1 \; 1 \; 1] = [\mathbf{P} \; | \; \mathbf{I_k}]$

- 여기서 ( $\mathbf{P}$ )는 패리티 비트를 생성하기 위한 부분 행렬이고, ( $\mathbf{I_k}$ )는 단위 행렬입니다.

2. 코드워드 ( $\mathbf{c}$ ) 생성
- 코드워드는 생성 행렬 ( $\mathbf{G}$ )를 사용하여 메시지 벡터 ( $\mathbf{m}$ )를 부호화하여 생성됩니다.
	- $\mathbf{c} = [\mathbf{b} \; | \; \mathbf{m}] = \mathbf{m}[\mathbf{P} \; | \; \mathbf{I_k}] = \mathbf{mG}$


3. 패리티 검사 행렬 ( $\mathbf{H}$ )
- 패리티 검사 행렬 ( $\mathbf{H}$ )는 수신된 코드워드가 오류가 있는지 검사하는 데 사용됩니다.
	- $\mathbf{H} = [\mathbf{I_4} \; | \; \mathbf{P^T}]$
	- $I_4$​: 4차원 단위 행렬.
	- $P^T$: P의 전치 행렬(transpose).
- 주어진 예시에서 ( $\mathbf{H}$ )는 다음과 같습니다: $$\mathbf{H} = \begin{bmatrix}
1 & 0 & 0 & 0 & 1 \\
0 & 1 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 & 1 \\
0 & 0 & 0 & 1 & 1 \\
\end{bmatrix}$$ 
- 해당 과정의 결과가 성립하면 오류가 없음을 의미하고, 그렇지 않으면 오류가 발생 했음을 의미
- **오류검출** : 수신된 코드워드 $r$ 에 대해, 패리티 검사 행렬 $H$를 곱하여 시드롬 $s$를 계산
	- $s = rH^T$ , 만약 $s=0$ 이면, 수신된 코드워드에 오류가 없음을 의미하고, 그렇지 않으면 오류가 발생했음을 의미
	- 이 과정을 통해 정보 비트를 부호화하고, 수신된 코드워드의 오류를 검출 및 수정할 수 있다. 부호화와 복호화 과정에서 생성행렬 $G$와 패리티 검사 행렬 $H$의 역할을 이해하는 것이 중요
#### 나머지 연산 (modulus operation)
- 나머지 연산은 두 수를 나눈 나머지를 구하는 연산입니다. 예를 들어, $a \mod b$는 $a$를 $b$로 나누었을 때의 나머지를 나타냅니다.

- 예시
	- $2 \mod 2 = 0$ : 2를 2로 나누면 나머지가 0입니다.
	- $1 \mod 2 = 1$ : 1을 2로 나누면 나머지가 1입니다.

- 신드롬 계산 예시
	- 신드롬 계산에서 각 항목에 대해 나머지 연산을 적용합니다: 
		- $s = [2 \mod 2, 1 \mod 2, 2 \mod 2, 2 \mod 2] = [0, 1, 0, 0]$ 

	- 위의 신드롬 계산 과정은 다음과 같이 이루어집니다:
	1. **첫 번째 항목**: $2 \mod 2 = 0$
	2. **두 번째 항목**: $1 \mod 2 = 1$
	3. **세 번째 항목**: $2 \mod 2 = 0$
	4. **네 번째 항목**: $2 \mod 2 = 0$
### 정리
- 반복 코드는 매우 단순하지만, 기본적인 오류 검출 및 수정 능력을 제공
- (5,1) 반복 코드의 경우, 단일 비트 메시지를 5번 반복하여 코드워드를 생성하며, 패리티 검사 행렬을 사용하여 수신된 코드워드에 오류가 있는지 검사할 수 있다.
- 이를 통해 통신 시스템에서 신뢰성을 향상 시킬 수 있다.

# Syndrome (신드롬)
- 오류 검출과 수정에 사용되는 중요한 개념, 수정된 코드워드의 오류 패턴을 식별하는데 사용
- 신드롬의 개념과 이를 계산하는 방법을 설명

### Vectors(벡터들)
1.	코드 벡터  $\mathbf{c}$ :
- $\mathbf{c} : (1 \times n)$
- 송신기에서 전송된 코드워드입니다.

2.	오류 벡터  $\mathbf{e}$ :
- $\mathbf{e} :  (1 \times n)$
- 오류 위치에서 1, 다른 위치에서 0인 벡터입니다. 
	- 예를 들어, 특정 위치에 오류가 발생하면 그 위치의 값이 1이 됩니다.

3.	수신 벡터  $\mathbf{r}$ :
- $\mathbf{r} = \mathbf{c} + \mathbf{e} :  (1 \times n)$
- 송신된 코드워드와 오류 벡터의 합으로, 수신기가 실제로 받는 벡터입니다.

### Syndrome 계산
1.	시드롬 벡터  $\mathbf{s}$ :
- $\mathbf{s} = \mathbf{rH^T} : (1 \times (n - k))$
	- 여기서  $\mathbf{H}$ 는 패리티 검사 행렬입니다. 
- 신드롬은 수신 벡터와 패리티 검사 행렬의 전치 행렬의 곱으로 계산됩니다.

#### 신드롬의 성질
1.	오류 벡터에만 의존:
- $\mathbf{s} = (\mathbf{c} + \mathbf{e}) \mathbf{H^T} = \mathbf{cH^T} + \mathbf{eH^T} = \mathbf{eH^T}$
- 여기서  $\mathbf{cH^T} = 0$ 이므로, 시드롬  $\mathbf{s}$ 는 오류 벡터  $\mathbf{e}$ 에만 의존하게 됩니다.
	
2.	동일한 신드롬:
- 모든 오류 패턴이 코드워드에 의해 달라지더라도, 동일한 시드롬을 가집니다. 
- 이는 신드롬이 특정 오류 패턴을 고유하게 식별할 수 있음을 의미합니다.

- 신드롬을 통해 수신된 코드워드의 오류를 검출하고, 이를 바탕으로 오류를 수정할 수 있다.
- 이 과정은 디지털 통신 시스템에서 데이터의 신뢰성을 보장하는 데 중요한 역할을 한다.

# Coset(코셋)
- 오류 벡터들을 그룹화하여 디코딩을 용이하게 하는 개념

### Coset 정의

- 코셋은 다음과 같이 정의됩니다:
- $\{ e_i = e + c_i, \; i = 1, \ldots, 2^k \}$

- 여기서 ( $e$ )는 오류 벡터이고, ( $c_i$ )는 코드워드입니다.

### Coset의 특성

1.	크기:
- $\text{코셋의 크기는 } 2^k \text{ 입니다.}$
- 코셋 내의 모든 벡터의 개수를 의미

2.	오류 벡터의 가능성:
- $\text{원래 오류 벡터의 가능성은 } 2^n \text{ 입니다.}$
- 모든 가능한 오류 벡터의 개수를 의미

3.	코셋 그룹화:
- $\text{이 오류 벡터들은 } 2^{n-k} \text{ 개의 코셋으로 그룹화됩니다.}$
- 모든 오류 벡터를 그룹으로 묶는 방법을 나타냄

4.	같은 코셋 내의 오류 벡터들:
- $\text{같은 코셋 내의 오류 벡터들은 동일한 시드롬을 가집니다.}$
- 동일한 코셋에 속한 벡터들이 같은 오류 패턴을 가짐을 의미
- $e_i H^T = e H^T + c_i H^T = e H^T$
	- 여기서 $( e_i = e + c_i )$이므로, 시드롬 계산 결과 $( e_i H^T )$는 $( e H^T )$와 동일합니다.
#### Coset의 사용
- 효율적인 오류 탐지 : 동일한 시드롬을 가지는 오류 벡터들을 한 그룹으로 묶어, 특정 신드롬에 대한 오류 벡터를 쉽게 찾을 수 있다
- 복호화 용이성 : 각 코셋의 대표 오류 벡터를 사용하여 빠르게 오류를 수정할 수 있다.
### Decoding (디코딩)
- 디코딩 과정은 수신된 벡터와 패리티 검사 행렬을 사용하여 오류를 검출하고 수정하는 과정입니다.

1.	수신 벡터:
- $\mathbf{r} = \mathbf{c} + \mathbf{e}$
- 여기서 ( $\mathbf{c}$ )는 송신된 코드워드, ( $\mathbf{e}$ )는 오류 벡터입니다.

2.	신드롬 계산:
- $\mathbf{s} = \mathbf{r} \mathbf{H^T} = \mathbf{e} \mathbf{H^T}$
- 신드롬 ( $\mathbf{s}$ )는 수신된 벡터 ( $\mathbf{r}$ )와 패리티 검사 행렬 ( $\mathbf{H}$ )의 전치 행렬을 곱하여 계산됩니다.

3.	코셋을 통한 디코딩:
- $\text{신드롬 계산 후, 같은 코셋 내의 } 2^k \text{ 개의 가능한 오류 패턴들이 존재합니다.}$
- 신드롬을 사용하여 디코딩하면 검색 공간이 $( 2^n )$에서 $( 2^k )$로 줄어듭니다.

### 정리
•	코셋 : 오류 벡터들의 집합으로, 각 코셋은 동일한 시드롬을 가집니다.
	•	크기는 ( $2^k$ )이며, 전체 오류 벡터는 ( $2^{n-k}$ )개의 코셋으로 그룹화됩니다.
•	디코딩 : 수신된 벡터에서 시드롬을 계산하여 오류를 검출합니다.
	•	신드롬을 통해 가능한 오류 패턴을 ( $2^n$ )에서  $2^k$ 로 줄여 디코딩합니다.

- 이 과정을 통해 오류 검출과 수정이 용이해지며, 통신 시스템에서 데이터의 신뢰성을 보장할 수 있습니다.

# Minimum Distance (1)

### Hamming weight
- 정의: 코드워드 ( $c$ )에서 0이 아닌 요소(비트)의 수를 말합니다.
- 표기: $w(c)$ 
	- 예시: 코드워드 ($c = 110100$ )인 경우, Hamming weight  $w(c)$ 는 3입니다.

### Hamming distance
- 정의: 두 코드워드 ( $c_1$ )와 ( $c_2$ ) 사이의 해밍 거리 ( $d(c_1, c_2)$ )는 두 코드워드가 다른 위치의 수를 말합니다.
- 표기:
	- $d(c_1, c_2) = |\{ i : c_{1,i} \neq c_{2,i}, 0 \leq i \leq n - 1 \}|$

- 추가 설명: 두 코드워드의 해밍 거리는 두 코드워드의 합의 해밍 weight와 동일합니다. 
	- 즉, $d(c_1, c_2) = w(c_1 + c_2)$

	- 이 식에서 ( + )는 모듈로 2 덧셈을 의미합니다.
		- 예시: 코드워드 ( $c_1 = 110100$ )과 ( $c_2 = 100110$ )이 있다면,  $d(c_1, c_2)$ 는 3입니다.

### 최소 거리  $d_{\min}$  of a linear block code
- 정의: 선형 블록 코드에서 임의의 두 코드워드 간의 해밍 거리 중 가장 작은 값을 말합니다.
- 동등한 정의: 이는 코드워드가 0이 아닌 경우의 해밍 weight 중 가장 작은 값을 의미합니다.
- 의의: 최소 거리는 오류 검출 및 오류 수정 능력을 결정하는 중요한 값입니다. 
	- 최소 거리가 클수록 더 많은 오류를 검출하고 수정할 수 있습니다.

- 위의 개념들은 정보 이론과 오류 정정 코드에서 중요한 역할을 하며, 통신 시스템에서 데이터 전송의 신뢰성을 향상시키기 위해 사용됩니다.

# Minimum Distance (2)

### 오류 정정 능력 (Error correction capability)
- 정의: 선형 블록 코드의 최소 거리 ( $d_{\min}$ )이 주어졌을 때, 이 코드는 최대 ( $t$ ) 비트의 오류를 정정할 수 있습니다.
- 조건: ( $d_{\min} \geq 2t + 1$ )일 때, 최대 ( $t$ ) 비트의 오류를 정정할 수 있습니다.
	- 예시: 만약 ( $d_{\min} = 5$ )라면, ( $t$ )는 ( $t \leq 2$ )이어야 합니다. 즉, 최대 2비트의 오류를 정정할 수 있습니다.

### 디코딩 (Decoding)
- 정의: 주어진 수신된 코드워드 ( $r$ )를 원래의 코드워드 ( $c$ )로 변환하는 과정입니다.
- 조건: 선형 블록 코드에서 ( $d_{\min}$ )가 주어졌을 때, 오류를 정정할 수 있는 최대 비트 수 ( $t$ )는$t \leq \left\lfloor \frac{1}{2}(d_{\min} - 1) \right\rfloor$ 입니다. 
	- 여기서 ( $\left\lfloor \cdot \right\rfloor$ )는 내림을 의미
	- 내림 함수 $\left\lfloor x \right\rfloor$
		- **정의**: $\left\lfloor x \right\rfloor$는 $x$보다 작거나 같은 가장 큰 정수를 반환합니다.
		- **예시**:
			- $\left\lfloor 3.7 \right\rfloor = 3$: 3.7보다 작거나 같은 가장 큰 정수는 3입니다.
		    - $\left\lfloor -1.2 \right\rfloor = -2$: -1.2보다 작거나 같은 가장 큰 정수는 -2입니다.

- 디코딩 규칙: 수신된 코드워드 ( $r$ )와 가장 가까운 코드워드 ( $c$ )로 디코딩합니다. 
	- 즉, 해밍 거리가 가장 작은 코드워드를 선택합니다.

### 그림 설명
- ![[Pasted image 20240612213135.png]]
	- 그림 (a): 코드워드 ( $c_i$ )와 수신된 코드워드 ( $r$ )가 있고, ( $t$ )만큼의 오류가 발생한 상황을 보여줍니다. 
		- ( $c_i$ )는 ( $r$ )에서 ( $t$ )만큼 떨어져 있습니다.
	- 그림 (b): 두 개의 코드워드 ( $c_i$ )와 ( $c_j$ )가 있고, 각각의 코드워드에서 ( $t$ )만큼 떨어진 영역이 겹치는 상황을 보여줍니다. 
		- ( $r$ )는 ( $c_i$ )와  $c_j$  둘 다와 겹칠 수 있으며, 이 경우 가장 가까운 코드워드로 디코딩합니다.

- 이와 같이 최소 거리를 통해 코드의 오류 정정 능력을 파악하고, 디코딩 시 수신된 코드워드와 가장 가까운 코드워드로 디코딩하여 오류를 수정하는 방법을 이해할 수 있습니다.

# Syndrome Decoding(1)
- 표준 배열을 사용하여 오류를 수정하는 방법

### 표준 배열 (Standard array)
- 정의: 모든 가능한 수신된 벡터 ( r )의 배열을 만듭니다.
#### 구성 방법:
1.	첫 번째 행:
- ( $e_1 = c_1 = 0$ )으로 설정합니다. 이는 모든 요소가 0인 벡터를 의미합니다.
- 첫 번째 행은 다음과 같은 하위 공간으로 구성됩니다:
	- $\{ e_1 + c_i \mid i = 1, …, 2^k \}$
- 여기서 ( $c_i$ )는 가능한 모든 코드워드입니다.

2.	두 번째 행부터:
- 남은 ( $r$ ) 중에서 가장 작은 weight를 가진 벡터 ( $e_j$ )를 선택합니다. 이 벡터를 코셋 리더라고 합니다.
- 이 벡터를 사용하여 다음과 같은 행을 만듭니다:
	- $\{ e_j + c_i \mid i = 1, …, 2^k \}$
- 이 과정은 모든 가능한 ( $r$ )를 배열에 포함시킬 때까지 반복됩니다.

### 신드롬 디코딩에서 코셋 리더 (Coset leaders in syndrome decoding)
- 정의: 코셋 내에서 가장 작은 weight를 가진 오류 벡터를 코셋 리더라고 합니다.
- 특징:
	- 오류 벡터의 weight가 작을수록 발생할 확률이 높습니다.
	- 각 행의 코셋 리더는 해당 코셋 내에서 최소 weight를 가진 벡터입니다.

### 예시
1.	( $e_1 = c_1 = 0$ )으로 설정하여 첫 번째 행을 구성합니다.
	- 예를 들어, 가능한 코드워드가 ( { 000, 011, 101, 110 } )라면, 첫 번째 행은 ( { 000, 011, 101, 110 } )이 됩니다.
2.	남은 ( $r$ ) 중에서 weight가 가장 작은 벡터 ( $e_2$ )를 선택합니다.
	- 예를 들어,  $e_2 = 001$ 이라면, 두 번째 행은  $\{ 001, 010, 100, 111 \}$ 이 됩니다.
3.	이 과정을 반복하여 모든 수신된 벡터를 배열에 포함시킵니다.

- 신드롬 디코딩은 수신된 벡터를 가장 가까운 코드워드로 변환하여 오류를 수정하는 강력한 방법입니다. 
- 이를 통해 오류 정정 능력을 향상시키고, 데이터 전송의 신뢰성을 높일 수 있습니다.

# Syndrome Decoding (2)
- 수신된 코드워드가 오류가 있는 경우 이를 올바르게 수정하는 방법을 제시

### 디코딩 절차 (Decoding procedure)
1.	코셋 결정 (Coset determination):
- 먼저  $e_1 = c_1 = 0$ 으로 설정합니다. 이 벡터는 모든 요소가 0인 벡터로, 이는 첫 번째 코셋을 정의합니다.
- 따라서 첫 번째 코셋은 $\{ c_1, c_2, c_3, …, c_{2^k} \}$ 가 됩니다. 여기서  $c_i$ 는 모든 가능한 코드워드입니다.

2.	코셋 리더 식별 (Identify coset leader):
- 각 코셋에서 가장 작은 weight를 가진 벡터  $\tilde{e}$ 를 선택합니다. 이 벡터는 해당 코셋의 리더가 됩니다.
- 이 코셋 리더  $\tilde{e}$ 는 가장 발생 확률이 높은 오류 패턴을 의미합니다.

3.	디코딩 (Decode):
- 수신된 벡터  $r$ 에 코셋 리더  $\tilde{e}$ 를 더하여 원래의 코드워드를 추정합니다.
- 즉,  $\hat{c} = r + \tilde{e}$ 로 디코딩합니다. 여기서  $\hat{c}$ 는 디코딩된 코드워드입니다.

### 표준 배열 예시
![[Pasted image 20240612214435.png]]
- 첫 번째 열은  $c_1 = 0$ 인 코셋입니다. 이는 $\{ c_1, c_2, c_3, …, c_{2^k} \}$ 로 구성됩니다.
- 두 번째 열부터는 각각의 코셋 리더  $e_i$ 를 기준으로 한 코셋입니다. 예를 들어, 두 번째 열은  $e_2$ 를 코셋 리더로 한 코셋으로 $\{ c_2 + e_2, c_3 + e_2, …, c_{2^k} + e_2 \}$ 로 구성됩니다.
	- 이 과정은 모든 가능한 수신된 벡터  r 를 포함할 때까지 반복됩니다.

- 각 열의 첫 번째 요소들은 코셋 리더들입니다. 
- 코셋 리더는 각 코셋에서 가장 작은 weight를 가진 벡터로, 발생 확률이 가장 높은 오류 패턴을 나타냅니다. 
- 따라서 수신된 벡터  r 를 가장 가까운 코드워드로 변환할 때 코셋 리더를 사용하여 디코딩합니다.

### 정리
- 코셋 결정:  $e_1 = c_1 = 0$ 으로 설정하여 첫 번째 코셋을 결정합니다.
- 코셋 리더 식별: 각 코셋에서 가장 작은 weight를 가진 벡터를 코셋 리더로 선택합니다.
- 디코딩: 수신된 벡터  $r$ 에 코셋 리더를 더하여 원래의 코드워드를 추정합니다.

- 이 과정을 통해 수신된 벡터에 발생한 오류를 수정하고, 원래의 코드워드를 정확하게 복원할 수 있습니다.

# Hamming Code (1)
- 수학적 정의 : Parity-check matrix의 각 column에 모든 nonzero vector들이 한번씩 나타나는 코드
	- H의 각 열이 서로 다른 고유한 이진 벡터(0이 아닌 벡터)로 구성되어야 한다는 것

### $(n,k)$ 해밍 코드
- 정의: 해밍 코드는 특정 길이의 데이터 블록에 대해 오류를 검출하고 수정할 수 있는 오류 정정 코드입니다.
- 수식: $( n = 2^m - 1 )$ : 전체 코드워드의 길이
	- $( k = 2^m - m - 1 )$: 데이터 비트의 길이
	- 여기서 ( $m$ )은 중복 비트의 수입니다.
- 중복 비트: ( $m$ )개의 중복 비트가 포함됩니다.

### (7,4) 해밍 코드

- 구성: 이 코드에서는 $( n = 7 ), ( k = 4 )$로 설정됩니다. 
	- 따라서, 4비트의 데이터 비트와 3비트의 중복 비트를 사용하여 7비트의 코드워드를 만듭니다.
	- 4개의 메시지 비트를 7개의 코드워드로 확장하는 코드, 이 경우 패리티 검사 행렬($H$)는 $3*7$ 크기를 가진다, 각 열은 고유한 3비트 이진 벡터로 구성

- 생성 행렬 (Generator matrix):
$$G = \begin{bmatrix}
1 & 1 & 0 & 1 & 0 & 0 & 0 \\
0 & 1 & 1 & 0 & 1 & 0 & 0 \\
1 & 1 & 1 & 0 & 0 & 1 & 0 \\
1 & 0 & 1 & 0 & 0 & 0 & 1 \\
\end{bmatrix}$$
![[Pasted image 20240612214708.png]]
- 이 행렬은 ( $P$ )와 ( $I_k$ )로 구성됩니다. 여기서 ( $P$ )는 중복 비트를 생성하는 부분, ( $I_k$ )는 단위 행렬입니다.
- $H$의 각 열은 고유한 non-zero벡터로 구성

•	최소 거리 (Minimum distance): 3
	•	최소 거리가 3이라는 것은, 해밍 코드가 최대 1비트의 오류를 수정할 수 있음을 의미합니다.
•	단일 오류 정정 코드 (Single-error correcting code): 이 코드는 단일 비트 오류를 검출하고 수정할 수 있습니다.
- 오류 검출 : 수신 된 코드워드가 한 비트 오류를 포함하고 있을 때 , 신드롬 벡터를 계산하여 그 비트의 위치를 정확하게 찾을 수 있다.
- 오류 수정 : 신드롬 벡터는 정확히 한 열과 일치하므로, 해당 위치의 비트를 뒤집어 오류를 수정할 수 있다.

#### 코드워드 테이블
- 메시지 비트와 이에 대응하는 코드워드를 보여주는 테이블입니다.
	- 예시 : 메시지 비트가 0000인 경우, 코드워드는 0000000이고, 해밍 weight는 0입니다.
		- 메시지 비트가 0001인 경우, 코드워드는 1011001이고, 해밍 weight는 3입니다.
![[Pasted image 20240612214742.png]]

### 정리
- $(n,k)$ 해밍 코드는 데이터 비트와 중복 비트로 구성된 오류 정정 코드입니다.
- (7,4) 해밍 코드는 7비트의 코드워드를 생성하며, 단일 비트 오류를 수정할 수 있습니다.
- 생성 행렬  G 를 사용하여 코드워드를 생성하며, 최소 거리는 3입니다.
- 코드워드 테이블을 통해 각 메시지 비트에 대응하는 코드워드를 확인할 수 있습니다.

- 해밍 코드는 효율적으로 오류를 검출하고 수정할 수 있어 데이터 통신에서 널리 사용됩니다.

# Hamming Code (2)

### 신드롬 디코딩 (Syndrome decoding)
![[Pasted image 20240612215100.png]]
1.	코드워드와 수신된 벡터:
- 원래 전송된 코드워드 ( $c = [1110010]$ )
- 수신된 벡터 ( $r = [1100010]$ )
	- 여기서 ( $r$ )은 전송 중 오류가 발생하여 하나의 비트가 바뀐 상태입니다.
2.	패리티 검사 행렬 (Parity-check matrix):
- 패리티 검사 행렬 ( $H$ )는 다음과 같이 정의됩니다:
$$H = \begin{bmatrix}
1 & 0 & 0 & 1 & 0 & 1 & 1 \\
0 & 1 & 0 & 1 & 1 & 1 & 0 \\
0 & 0 & 1 & 0 & 1 & 1 & 1
\end{bmatrix}$$

- 이 행렬은 ( $I_{n-k}$ )와 ( $P^T$ )로 구성됩니다.

3.	신드롬 계산 (Syndrome calculation):
- 수신된 벡터 ( r )와 패리티 검사 행렬 ( H )를 곱하여 신드롬 ( s )를 계산합니다:
	- $s = rH^T$
		- 1. $r$는 $[1100010]$
		- 2. $H$의 전치 행렬 $H^T$는 $H$의 행과 열을 바꾼 행렬입니다:
		- $H^T = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \\ 1 & 1 & 0 \\ 0 & 1 & 1 \\ 1 & 1 & 1 \\ 1 & 0 & 1 \end{bmatrix}$​​
- 이 계산의 결과는 다음과 같습니다:
$$s = [1100010] \begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1 \\
1 & 1 & 0 \\
0 & 1 & 1 \\
1 & 1 & 1 \\
1 & 0 & 1
\end{bmatrix} = [0 0 1]$$

	- 신드롬 ( $s = [0 0 1]$ )은 오류 패턴을 나타내는 벡터입니다.

4.	디코딩 테이블 참조:
![[Pasted image 20240612215107.png]]
- 신드롬 ( $s = [0 0 1]$ )은 디코딩 테이블에서 오류 패턴을 찾기 위해 사용됩니다.
- 디코딩 테이블에 따르면 신드롬 ( $[0 0 1]$ )은 오류 패턴 ( $0010000$ )에 해당합니다. 
	- 이는 3번째 비트에 오류가 있음을 의미합니다.

5.	오류 수정 (Error correction):
- 수신된 벡터 ( r )에서 7번째 비트를 수정하여 원래 코드워드 ( c )를 복원합니다.
- 따라서, ( $r = [1100010]$ )에서 7번째 비트를 수정하면 원래 코드워드 ( $c = [1110010]$ )를 얻습니다.

### 정리
- 신드롬 디코딩은 수신된 벡터와 패리티 검사 행렬을 사용하여 오류를 탐지하고 수정하는 과정입니다.
- 패리티 검사 행렬 ( H )를 통해 신드롬  s 를 계산합니다.
- 계산된 신드롬을 디코딩 테이블과 비교하여 오류 패턴을 찾습니다.
- 오류 패턴을 기반으로 수신된 벡터의 오류를 수정하여 원래 코드워드를 복원합니다.

- 이를 통해 해밍 코드는 단일 비트 오류를 효과적으로 탐지하고 수정할 수 있습니다.