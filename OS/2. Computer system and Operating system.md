 > 울산대학교 Ai융합전공, 2024년 4학년 1학기, 운영체제 / 수업 내용 및 추가 학습 서술

- 하드웨어의 구조와 작동원리 핵심 이해
- 운영체제의 위치와 역할 및 전체기능 이해
- 시스템 호출과 인터럽트 이해
- 사용자 모드와 커널모드에 대해 이해하고, 이들을 두는 목적등을 이해
- 메모리공간을 사용자공간과 커널공간으로 나누어 활용함을 이해
- 운영체제 커널의 개념과 실체 이해
# 컴퓨터 시스템과 하드웨어

### 컴퓨터 시스템의 범위
- 컴퓨터 시스템 구성 계층
	- 응용소프트웨어
	- 운영체제
	- 컴퓨터 하드웨어

- 컴퓨터 시스템 계층 구조 특징
	- 응용프로그램, GUI/ 도구프로그램을 통해 컴퓨터 활용
	- 하드웨어는 운영체제의 **배타적 독점적 지배**를 받음
	- 사용자나 응용프로그램의 하드웨어에 대한 직접 접근 불허

- 계층 구조로 보는 운영체제의 기능
	- 사용자가 하드웨어에 대해 몰라도 컴퓨터를 사용할 수 있다.
	- 응용 프로그램과 하드웨어 사이의 **중계**

## 컴퓨터 하드웨어 설명
- CPU
	- 프로그램 코드를 해석하여 실행하는 중앙처리 장치
	- 메모리 적재된 프로그램 실행
- 메모리
	- CPU에 의해 실행되는 프로그램 코드와 데이터가 적재되는 공간
- 캐시 메모리
	- CPU 처리속도가 메모리 속도에 비해 빠르게 향상 -> 느린 메모리 때문에 CPU의 대기 시간이 늘었음
	- 온칩 캐시
	- 오프칩 캐시 - CPU 외부 설치
	- 캐시 메모리가 있는 경우 CPU는 캐시 메모리에서만 프로그램 실행
- 입출력 장치
- 버스 (Bus)
	- 하드웨어들이 데이터를 주고 받기 위해 0과 1의 디지털 신호가 지나가는 여러 가닥의 선을 다발로 묶어 부르는 용어
		- 주소버스
		- 데이터 버스
		- 제어버스
	- 주소
		- 0번지에서 시작하는 양수
		- 주소버스는 주소 값이 전달되는 여러 선의 다발
		- CPU는 메모리나 입출력 장치에 값을 쓰거나 읽을 때 반드시 주소를 발생시킴

- 목적에 따라 버스 구분
	- 시스템 버스
		- CPU, 캐시 메모리, 메모리 등 빠른 하드웨어들 사이
		- 고속도로
	- 입출력버스
		- 상대적으로 느린 입출력 장치들로부터 입출력 데이터 전송
		- 일반도로
- I/O 컨트롤러, 컨트롤 회로
	- 입출력 제어 장치 및 시스템 제어 회로
	- 입출력 장치들을 제어하기 위한 여러 하드웨어
	- DMAC : CPU개입 없이 I/O장치와 메모리 사이의 데이터 전송
	- 인터럽트 제어장치 : 장치들이 보낸 interrupt를 CPU로 전달

### CPU와 메모리의 관계
- CPU - 능동적 소자, 메모리 액세스 시 주소 발생
- 32비트 CPU, 32비트 운영체제, 32비트 컴퓨터란?
	- CPU에 32개의 주소선이 있음
	- CPU의 엑세스 범위 : 2^32개의 서로 다른 주소(0~2^(32)-1)
	- CPU가 최대 엑세스 할 수 있는 메모리의 크기 : 4GB
	- 한 번지의 공간이 1바이트이므로, **2^32개의 주소 = 2^32바이트 = 4GB**
	- 32비트 CPU를 가진 컴퓨터에 4GB이상 메모리를 설치할 경우
		- 4GB를 넘어선 영역은 사용할 수 없음
- CPU에 입출력되는 32개의 데이터 선이 있음 (32비트는 4개의 주소)

### 32비트 CPU의 주소선과 메모리

![[Pasted image 20240312143709.png]]
- A0~A31은 32개의 주소선
- D0~D31은 32개의 데이터선
-> 이들은 시스템 버스와 연결되어 다른 하드웨어 장치들에게 주소를 보내거나 데이터를 주고 받음

- 주소에 초점을 맞추기 위해 32비트 컴퓨터를 32개의 주소선을 가진 것으로 설명,
- 32비트 CPU는 32개 데이터선을 통해 32비트를 한 번에 메모리에서 읽고 쓰고 한 번에 32비트 더하기를 한다.

## 명령 ( instruction )
- CPU명령
	- CPU가 해석하고 실행할 수 있는 기계 명령
	- CPU 사이에 명령들의 호환성 없음
		- C프로그램을 어떤 CPU를 대상으로 컴파일 하였는지에 따라 기계어가 달라지므로, 컴파일된 코드는 CPU 사이에 호환성이 없음
![[Pasted image 20240312145229.png]]
### 명령 처리 과정
- CPU레지스터들
	- PC(program counter) - 다음에 실행할 명령의 메모리 주소 저장
	- IR(instruction register) - 메모리로부터 읽어 온 명령 저장
	- SP(stack pointer) - 스택의 톱 메모리 주소저장
	- 데이터 레지스터 - 연산에 사용되거나 사용될 데이터들 저장
	- 상태 레지스터 - CPU의 실행 상태 정보나 인터럽트 금지 등의 제어 정보 저장
	- 기타 - 페이지 테이블이 저장된 메모리 주소를 가리키는 레지스터

- 명령어 사이클
	- CPU가 하나의 명령을 실행하는 과정
	- CPU는 전원이 켜진 후 단순하게 명령 사이클 반복
- 명령 사이클 사례 : 메모리 100번지에 저장된 다음 명령을 실행하는 사례
	- `mov eax, [300]`; 메모리 300번지의 값을 읽어 eax 레지스터에 저장
```
1. CPU는 PC 레지스터가 가리키는 주소(100)를 주소 버스에 싣는다.
2. 메모리는 100번지에 저장된 데이터(mov eax, [300])를 데이터 버스에 싣는다. (memory read)
3. CPU는 데이터 버스에 담긴 바이너리 값들을 IR 레지스터에 저장. PC를
다음 번지로 수정한다.
4. CPU는 연산에 필요한 데이터를 읽기 위해 데이터의 주소(300)를 주소
버스에 싣는다.
5. 메모리는 300번지에 저장된 50을 데이터 버스에 싣는다.
6. CPU는 데이터 버스로부터 50을 임시 데이터 레지스터에 저장된다.
7. 이제 CPU는 명령을 해석하고 명령을 실행한다. 명령 실행 결과, 50이 eax 레지스터에 저장된다.
```

![[Pasted image 20240312150614.png]]

## 스택 ( Stack )
- 프로그램이 실행되기 위해 **운영체제에 의해 할당**되는 공간
	- 코드공간 - 프로그램 코드 적재
	- 데이터 공간 - 전역 변수들이 적재되는 공간
	- 힙 공간 - 프로그램에서 동적 할당 받는 공간
	- 스택 공간 - 함수가 호출될 때 매개변수, 지역변수 등
- 스택
	- 별도의 하드웨어 메모리는 아님
	- 메모리의 일부를 스택으로 사용하도록 할당된 공간
	- **각 프로그램에게 자산만의 스택 공간 할당**
	- **SP레지스터**는 현재 실행중인 프로그램의 스택 꼭대기 주소를 가리킴
```
스택에 저장되는 내용
- 함수의 지역변수
- 함수가 호출될 때 전달받은 매개변수 값
- 함수가 실행된 후 돌아갈 주소
- 함수가 의도적으로 저장해두기 위한 값
```

![[Pasted image 20240320201250.png]]
## 컨텍스트 (Context)
- 프로그램이 실행 중인 일체의 상황 혹은 상황 정보
	- 메모리 - 프로그램 코드와 데이터, 스택, 동적할당 받아 저장한 값
	- CPU 레지스터들의 값 - PC에는 코드의 주소, SP에는 스택의 주소, 다른 레지스터는 이전의 실행 결과나 현재 실행에 사용되는 데이터 들
- 컨텍스트 스위칭
	- 현재 실행중인 프로그램의 컨텍스트를 메모리에 저장
	- 새로 실행시킬 프로그램의 저장된 컨텍스트를 CPU에 복귀
		- 발생 - CPU가 현재 프로그램 실행을 **중지**하고 **다른 프로그램을 실행**할때

## 멀티코어 CPU
- 2001년 IBM에 의해 PowerPC라는 멀티코어 CPU개발
	- CPU내부에 2개의 프로세서 포함
	- 2개의 프로그램을 동시에 실헹
	- 코어는 완벽한 처리기 (과거개념의 CPU)

# 컴퓨터 시스템과 운영체제
- 컴퓨터 시스템 계층
	- 소프트웨어 영역
		- 사용자
		- 응용프로그램
		- 운영체제
			- 커널 코드
			- 디바이스 드라이버 (드라이버를 만드는 회사가 만든다.)
	- 하드웨어 영역
		- 컴퓨터 하드웨어

- System Call : 응용프로그램에서 운영체제를 호출
- Device Call : 운영체제에서 컴퓨터 하드웨어를 호출
- 인터럽트 : 하드웨어 -> 운영체제 -> 응용프로그램 -> 사용자 로 향하는 모든 각각의 과정을 의미
## 계층 구조로 설계된 이유
- 계층간 독립성 확보
	- 사용자가 운영체제나 하드웨어에 대해 몰라도 응용프로그램을 컴퓨터를 활용할 수 있게 만듬
	- 응용프로그램
		- 컴퓨터 하드웨어의 타입이나 구조, 제어 방법을 몰라도 개발 가능
		- 운영체제에게 요청하여 HW 접근 해결
		- 컴퓨터 하드웨어가 바뀌어도 응용프로그램을 다시 작성할 필요 없음
	- 운영체제
		- 장치 관련된 모든 작업을 **디바이스 드라이버**에게 요청
		- 응용 프로그램과 하드웨어 사이의 인터페이스

## 운영체제 필요성
- 운영체제가 없다면
	- 응용프로그램이나 사용자가 직접 하드웨어를 제어해야 함
	- 하드웨어에 대한 지식이 필요, 충돌, 관리, 보안의 문제 발생
-> 자원에 대한 충돌해결, 성능 최적화, 사용자의 시스템 사용 효율화

![[Pasted image 20240312153147.png]]

## 운영체제와 응용프로그램 사이의 관계
- 응용프로그램에 대한 운영체제의 역할
	- 직접 하드웨어를 다루지 못하도록 차단
		- 운영체제가 하드웨어를 **완벽히 독점 장악**
		- 응용프로그램들 사이의 하드웨어 사용 충돌을 막기 위함
	- 하드웨어를 사용하고자 할 때
		- 운영체제에게 요청 -> 운영체제가 대신 하드웨어 조작
		- 유일한 요청방법 : System call
	- 응용프로그램과 하드웨어 사이의 인터페이스
	- 응용프로그램들의 실행순서 제어
	- 응용프로그램들 사이의 통신 중계

## 운영체제와 사용자의 관계
- 사용자는 응용프로그램을 통해 컴퓨터 사용
- 역할
	- 하드웨어 지식 없어도 컴퓨터 다루기 용이
	- 하드웨어 설치 및 변경 가능
	- 컴퓨터 시스템을 사용할 편리한 인터페이스 제공
	- 컴퓨터 사용을 돕는 여러 도구 응용프로그램 제공
	- 사용자의 계정관리
	- 사용자의 컴퓨터 사용시간계산, 과금처리

## 운영체제의 전체 기능
- 프로세스와 스레드 관리
- 메모리 관리
- 파일 관리, 파일 시스템 관리
- 장치 관리
- 사용자 인터페이스
- 네트워킹
- 보호 및 보안

![[Pasted image 20240313161601.png]]
## 운영체제 구성
- 운영체제 = 커널 + 도구 + 디바이스 드라이버
- 커널
	- 핵심부분
	- 부팅 후 메모리에 상주하는 코드와 데이터
	- 컴퓨터 자원을 직접 제어하고 관리하는 코드와 자료구조
	- 커널 코드 = 함수들의 집합
	- 커널 기능 이용하려면 응용프로그램을 반드시 시스템 호출 사용
- 도구 S.W와 GUI
	- 사용자가 컴퓨터를 편리하게 사용하기 위해 제공 S.W
- 디바이스 드라이버
	- 장치를 직접 제어하고 입출력하는 소프트웨어
	- 장치 제작자에 의해 작성되어 배포됨

## 운영체제 커널 인터페이스
- 2개의 인터페이스 : 시스템호출, 인터럽트
	- 응용프로그램과 하드웨어 사이의 중계역할
- 시스템호출
	- 커널과 응용프로그램 사이의 인터페이스
	- 응용프로그램에서 커널 기능을 사용할 수 있는 유일한 방법
	- 시스템호출라이브러리를 통해 **시스템 호출 함수** 제공
	- 라이브러리
		- 응용프로그램을 쉽게 작성할 수 있도록 복잡한 기능이 미리 작성된 코드
		- 운영체제 커널의 기능과 무관한 작업
		- 응용프로그램은 표준라이브러리 함수를 함수호출 방법으로 사용
-  인터럽트
	- 커널과 하드웨어 장치 사이의 인터페이스
	- 장치상태를 **CPU에게 알리는** 하드웨어적 방법
	- 인터럽트가 발생하면?
		- CPU는 하는 일 중단, 인터럽트 서비스 루틴 실행
		- 서비스 루틴은 디바이스 드라이버 내에 있음
		- 인터럽트 서비스 루틴은 커널 영역에 적재
		- 서비스루틴의 실행이 끝나면 하던 작업 계속

# 커널과 시스템 호출

## 응용프로그램의 자원 접근 문제
- 다중 프로그래밍 운영체제
	- 문제 : 응용프로그램이 직접 컴퓨 자원에 접근하면 충돌과 훼손 발생
	- 해결 : 응용프로램의 자원 접근 불허 (커널만 가능)
	- 구체적 해결
		- 1. 메모리 공간을 사용자 공간과 커널 공간으로 분리
		- 2. CPU의 실행모드를 사용자 모드와 커널 모드로 분리
		- 3. 응용프로그램은 시스템 호출을 이용해서만 커널 코드 이용

## 사용자 공간과 커널 공간
- 운영체제는 컴퓨터 메모리를 두 공간으로 분리
	- 사용자 공간
	- 커널 공간
- 사용자 공간 : 모든 응용프로그램들이 나누어 사용하는 공간
- 커널 공간 : 커널만 사용할 수 있는 공간
- 분리 이유 : 커널 코드와 데이터를 악의적인 응용프로그램이나 코딩 실수로부터 지키기 위함

## 사용자 공간 크기의 의미
- 사용자 공간 크기
	- 한 응용프로그램의 최대 크기 결정
		- 프로그램 코드 + 데이터(전역변수) + 동적할당 + 스택을 합친 크기
		- ex ) 32비트 윈도우 사용자공간 2GB = 응용프로그램의 크기가 최대 2GB
- 사용자 공간의 주소 범위
	- 응용프로그램은 운영체제가 설정한 사용자 공간의 주소 범위를 넘어 설 수 없음
		- ex) 32비트 윈도우 운영체제 : 응용프로그램은 0~7FFFFFFF범위의 주소를 넘어 액세스하게 되면 바로 종료 ( 심각한 오류 )

## 주소 공간은 가상 주소 공간
- 주소 공간  = 사용자공간 + 커널공간
- 주소공간은 가상주소공간
	- 물리메모리의 주소범위와 무관
- 가상주소공간
	- 사용자나 응용프로그램 관점에서 보는 주소 범위
	- 사용자가 전체 메모리를 사용하고 있다고 착각
- 커널공간 (2GB~4GB-1의 주소범위)
	- 80000000~FFFFFFFF범위 주소공간
	- 모든 응용프로그램은 커널 공간 공유

## 사용자 모드와 커널 모드
- CPU는 사용자 모드와 커널 모드 중 한 모드로 실행
	- CPU내부에 모드 상태를 나타내는 '모드 레지스터'있음
- 사용자 모드
	- CPU의 모드 비트 = 1
	- CPU는 사용자 공간에 있는 코드나 데이터를 액세스하는중
	- CPU의 커널 공간 접근 불허 -> 응용프로그램으로부터 커널 영역 보호
	- 특권 명령 실행 불허
		- 특권명령 : 입출력 장치 등 하드웨어나 시스템 중단 등 시스템 관련 처리를 위해 설계된 특별한 명령
- 커널모드
	- CPU의 모드 비트 = 0
	- CPU가 커널 공간에서 실행하는 중, 혹은 사용자 코드를 실행하는 중
	- 특권 명령 사용가능

## 사용자 모드에서 커널 모드로 전환
- 2가지 경우
	- 시스템 호출 (동기적)
	- 인터럽트 발생 (비동기적)
- 시스템 호출 : 특별한 기계 명령에 의해 진행
	- 기계명령이 CPU의 모드 비트를 커널 모드로 전환
- 인터럽트 : CPU가 인터럽트를 수신하면 커널모드로 자동전환 (인터럽트 서비스 루틴이 커널공간(device driver)에 있기때문)
	- CPU는 인터럽트 서비스 루틴 실행
	- 인터럽트 서비스 루틴이 끝나면 CPU는 사용자 모드로 자동전환

## 특권명령
: 커널 모드에서 실행할 특별한 목적으로 설계된 CPU 명령

### 종류
- I/O 명령
- Halt 명령
	- CPU의 작동을 중지시키는 명령, CPU를 유휴상태로 만듬
- 인터럽트 플래그를 켜고 끄는 명령
	- CPU내에 있는 인터럽트 플래그 비트를 제어하여 CPU가 인터럽트를 허용하거나 무시하도록 지시
	- Cli/sti 명령
- 타이머 설정 명령
- 컨텍스트 스위칭 명령
- 메모리 지우기 명령
- 장치 상태 테이블 수정등의 명령

## 커널의 실체
- 커널은 부팅 시에 커널 공간에 적재된 함수들과 시스템 관리를 위한 데이터(테이블, 구조체)집합
	- 커널은 컴파일 된 바이너리 형태, 하드디스크 특정 영역에 저장, 부팅 시에 커널 공간의 메모리에 적재
- 커널 코드는 함수들의 집합
	- 커널의 존재 - 커널모드에서 실행되는 함수들과 데이터들의 집합
