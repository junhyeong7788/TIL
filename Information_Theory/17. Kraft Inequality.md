: 특정 코드가 어떤 조건을 만족하는지를 판단하는데 사용됨
- 즉시 해독 가능한 코드(instantaneous code) 또는 접두어 코드(prefix code)에 적용됨

## 즉시 해독 가능한 코드란?
- 어느 코드워드도 다른 코드워드의 접두어(prefix)가 되지 않은 코드를 말함
	- 예를 들어, "10", "01", "001"과 같은 코드가 있다. 
	- 여기서 "10"은 다른 어떤 코드워드의 접두어가 아니다.

## 크래프트 부등식의 내용

### 정리
: 어떤 크기의 𝐷의 알파벳을 사용하는 모든 즉시 해독 가능한 코드에 대해, 코드워드 길이 l1, l2,...,lm은 다음 부등식을 만족해야한다.

![[Pasted image 20240522182637.png]]

- 여기서 𝐷는 알파벳의 크기이고, l_i는 각 코드워드의 길이이다.
- 반대로, 이 부등식을 만족하는 코드워드 길이의 집합이 주어지면, 이 길이를 가지는 즉시 해독 가능한 코드가 존재한다.

### 예시
- 이진수 코드 (알파벳크기 𝐷 = 2)를 사용하는 경우
![[Pasted image 20240522184245.png]]
- 따라서 이 코드워드 길이 집합은 즉시 해독 가능한 코드가 될 수 있다.

### 요약
- 크래프트 부등식은 즉시 해독 가능한 코드가 되기 위한 코드워드 길이들의 필요충분조건을 제공한다.
- 이 부등식을 만족하면 그 코드워드 길이들로 즉시 해독 가능한 코드를 만들 수 있다.

## 증명 (1)

1. D-진 트리
- D-진 트리 : 각 노드가 D개의 자식을 가지는 트리 구조
- 여기서 각 코드워드는 트리의 잎사귀에 해당, 즉, 각 코드워드는 트리의 말단 노드에 위치

2. 접두어 코드 조건(Prefix-Free Condition)
- 접두어 코드 조건 : 어느 코드워드도 다른 코드워드의 접두어가 되지 않는다는 의미
- ex : 코드워드 "10" 은 "100"의 접두어가 될 수 없다. 따라서 "10"이 코드워드라면 "100"은 사용할 수 없다.

### 트리 구조에서의 코드워드
 - 트리의 루트에서 시작하여 각 노드를 따라가면서 코드워드를 형성
	 - ex : "0"은 첫 번째 자식 노드로, "10"은 두 번째 레벨의 자식 노드로 나타낼 수 있다.

### 접두어 코드의 의미
- 접두어 코드 조건에 따르면, 어떤 코드워드도 다른 코드워드의 조상이 될 수 없다.
	- ex : 코드워드 "10"이 사용되면, "10"을 포함하는 "100", "101"등의 모든 후손 코드워드는 사용되지 않는다.
- 따라서 코드워드가 트리에서 한 위치를 차지하면 그 아래 모든 노드는 코드워드로 사용할 수 없게 된다.

### 요약
- D-진 트리에서 접두어 코드 조건을 만족하는 코드는 트리의 잎사귀 노드에 위치
	- 각 코드워드는 접두어가 아니므로, 트리 구조에서 한 코드워드가 선택되면, 그 아래 모든 후손 노드는 선택 될 수 없다.

## 증명(2)

### 부등식 증명
1. 최장 코드워드 길이 설정
- lmax는 코드워드 집합에서 가장 긴 코드워드 길이이다.
	- ex : 코드워드의 집합이 "0", "10", "110"이라면, lmax = 3이다.

2. 코드워드의 후손
- 길이가 li 인 코드워드는 lmax레벨에서  𝐷^lmax-li 개의 후손을 가질 수 있다.
- 여기서  𝐷는 각 노드가 가질 수 있는 자식 노드의 수를 의미 (이진트리에서는  𝐷 = 2 이다.)
- 각 코드워드의 후손 집합은 서로 겹치지 않음

3. 모든 코드워드에 대한 합계
- 모든 코드워드에 대해 후손의 수를 합산하면 : 
- ![[Pasted image 20240522185828.png]]
- 이를 정리하면 : 
- ![[Pasted image 20240522185840.png]]

### 존재 증명(Existence)

1.  크래프트 부등식을 만족하는 코드워드 길이 집합
- 크래프트 부등식을 만족하는 코드워드 길이 집합 l1, l2,..., lm가 주어졌을 때, 우리는 이들을 이용하여 트리를 구성할 수 있다.

2. 트리 구성 방법
- 깊이 l1의 첫 번째 노드를 코드워드 1로 레이블 한다. 그리고 이 노드의 모든 후손을 트리에서 제거함
- 싶이 l2의 남아있는 첫 번째 노드를 코드워드 2로 레이블하고, 이 노드의 모든 후손을 트리에서 제거한다.
- 이 과정을 반복하여 모든 코드워드를 트리에 할당함

### 요약
- 이 증명은 접두어 코드의 길이들이 크래프트 부등식을 만족하면, 그 코드워드들로 즉시 해독 가능한 코드를 구성할 수 있음을 보여준다.
- 이를 통해 우리는 효율적이고 충돌 없는 코드워드 집합을 만들 수 있다.

## 확장된 크래프트 부등식 (Extended Kraft Inequality)
: 기존의 크래프트 부등식을 무한한 코드워드 집합에 대해 확장한 것
- 조건 : 접두어 코드를 형성하는 코드워드들의 셀수있는 무한 집합이 대해
- 내용 : 코드워드 길이 li들이 확장된 크래프트 부등식을 만족해야한다.
![[Pasted image 20240522195132.png]]
- D는 알파벳의 크기
- 반대로 이 부등식을 만족하는 코드워드 길이 l1, l2,...가 주어진다면, 이 길이를 가지는 즉시 해독가능한 코드가 존재(instantaneous code)한다.


